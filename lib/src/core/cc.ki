
use os;
use mem;

// ki cycle collector

struct CycleCollector[T] {

	block_cc: ptr;
	block_cc_end: ptr;
	block_alloc: ptr;
	index_cc: uxx = 0;
	index_cc_end: uxx = 0;
	index_alloc: uxx = 0;
	race: uxx = 0;
	mut: os:Mutex = os:Mutex.new();

	static fn create() CLASS {
		let block = mem:calloc(1001 * @sizeof(ptr));
		let res = CLASS {
			block_cc: block,
			block_cc_end: block,
			block_alloc: block,
		};
		//print("create: %\n"{ (res @as ptr).str() });
		return res;
	}

	fn add_item(item: *T) {
		//print("this: %\n"{ (this @as ptr).str() });
		//print("add: %\n"{ (item @as ptr).str() });
		while true {
			let block = this.block_alloc;
			let index = @atomic_op this.index_alloc ADD 1;
			//print("i:%\n"{ index.str() });
			if index >= 1000 {
				// Allocate more space
				//while true {
				//	if this.race == 0 {
				//		let nr = atomic_op this.race ADD 1;
				//		if nr == 0 {
				//			break;
				//		}
				//	}
				//	os:sleep_ms(1);
				//}
				//print("nb\n");
				os:sleep_ms(1);
				this.mut.lock();
				if this.block_alloc != block {
					this.mut.unlock();
					continue;
				}
				// Alloc new block
				let new_block = mem:calloc(1001 * @sizeof(ptr));
				@ptrv(block, ptr, 0) = new_block;

				this.block_alloc = new_block;
				this.index_alloc = 0;
				this.mut.unlock();
				continue;
			}

			@ptrv(block, ptr, index + 1) = item @as ptr;
			break;
		}
	}

	fn start() {
		this.block_cc_end = this.block_alloc;
		this.index_cc_end = this.index_alloc;
		while this.index_cc_end >= 1000 {
			this.block_cc_end = this.block_alloc;
			this.index_cc_end = this.index_alloc;
		}

		// Reset fields
		let block = this.block_cc;
		let block_items = block + @sizeof(ptr);
		let index = this.index_cc;
		let block_end = this.block_cc_end;
		let index_end = this.index_cc_end;
		while block != block_end || index != index_end {
			if index == 1000 {
				block = @ptrv(block, ptr, 0);
				block_items = block + @sizeof(ptr);
				index = 0;
				continue;
			}
			let item = @ptrv(block_items, *T, index);
			if item._RC > 0 {
				item._RC_CHECK = 0;
				item._CC_KEEP = 0;
				item._CC_CHANGED = 0;
			}
			index++;
		}
	}
	fn rc_check_items() {
		// _RC_CHECK + 1 on each circular property (non-recusrive)
		let block = this.block_cc;
		let block_items = block + @sizeof(ptr);
		let index = this.index_cc;
		let block_end = this.block_cc_end;
		let index_end = this.index_cc_end;
		while block != block_end || index != index_end {
			//print("index: %\n"{ index.str() });
			if index == 1000 {
				block = @ptrv(block, ptr, 0);
				block_items = block + @sizeof(ptr);
				index = 0;
				continue;
			}
			let item = @ptrv(block_items, *T, index);
			//print("%\n"{ (item @as ptr).str() });
			if item._RC > 0 {
				item.__cc_check_props();
			}
			index++;
		}
	}
	fn mark_keep() {
		// Set call __cc_keep() on each object where _rc != _rc_check or _cc_changed = 1
		let block = this.block_cc;
		let block_items = block + @sizeof(ptr);
		let index = this.index_cc;
		let block_end = this.block_cc_end;
		let index_end = this.index_cc_end;
		while block != block_end || index != index_end {
			if index == 1000 {
				block = @ptrv(block, ptr, 0);
				block_items = block + @sizeof(ptr);
				index = 0;
				continue;
			}
			let item = @ptrv(block_items, *T, index);
			if item._RC > 0 && item._RC != item._RC_CHECK || item._CC_CHANGED == 1 {
				if item._CC_KEEP == 0 {
					item.__cc_keep();
				}
			}
			index++;
		}
	}
	fn deref_cycle_objects() {
		// Deref objects where RC == RC_CHECK and _CC_KEEP == 0
		let block = this.block_cc;
		let block_items = block + @sizeof(ptr);
		let index = this.index_cc;
		let block_end = this.block_cc_end;
		let index_end = this.index_cc_end;
		while block != block_end || index != index_end {
			if index == 1000 {
				block = @ptrv(block, ptr, 0);
				block_items = block + @sizeof(ptr);
				index = 0;
				continue;
			}
			let item = @ptrv(block_items, *T, index);
			if item._RC > 0 && item._CC_KEEP != 1 {
				item._RC++;
				//print("deref\n");
				item.__deref_props();
				item._RC--;
			}
			index++;
		}
	}
	fn free_unused() {
		// Free objects where RC == 0 and RC_WEAK == 0
		// Also re-add items and free blocks if you reached the end of it
		let block = this.block_cc;
		let block_items = block + @sizeof(ptr);
		let index = this.index_cc;
		let block_end = this.block_cc_end;
		let index_end = this.index_cc_end;
		while block != block_end || index != index_end {
			if index == 1000 {
				let next_block = @ptrv(block, ptr, 0);
				mem:free(block);
				block = next_block;
				block_items = block + @sizeof(ptr);
				index = 0;
				continue;
			}
			let item = @ptrv(block_items, *T, index);
			if item._RC == 0 && item._RC_WEAK == 0 {
				mem:free(item @as ptr);
			} else {
				this.add_item(item);
			}
			index++;
		}

		// Set next start position
		this.block_cc = block;
		this.index_cc = index;
	}
	fn end() {
	}
}
