
header "ki_os" as os;

global allocators : ?ptr;
global allocators2 : ?ptr;

#if 1
func alloc(size: uxx) ptr {
	return os.ki_os__alloc(size);
}
func free(adr: ptr) void {
	os.ki_os__free(adr);
}
#else
func alloc(size: uxx) ptr {
	let alcs = allocators;
	if alcs == null {
		let size : uxx = 64#uxx * sizeof(ptr);
		let list = sys_alloc(size);
		clear(list, size);
		allocators = list;
		alcs = list;
	}

	let pow = 1#u8;
	let cmp = 32#uxx;
	while cmp <= size {
		cmp = cmp << 1;
		pow += 1;
	}

	let adr : ptr = (alcs @as ptr) + (pow * sizeof(ptr));
	let alc = @ptrv(adr, ?Allocator, 0);
	if alc == null {
		alc = Allocator.init(cmp + 1);
		@ptrv(adr, ?Allocator, 0) = alc;
	}
	// Get chunk
	rep alc = alc @as Allocator;
	let res = alc.alloc();
	@ptrv(res, u8, 0) = pow;

	return res + 1;
}
func free(adr: ptr) void {
	let alcs = allocators @as ptr;
	adr-=1;
	let pow : u32 = @ptrv(adr, u8, 0);
	let alc_adr = alcs + (pow * sizeof(ptr));
	let alc = @ptrv(alc_adr, Allocator, 0);
	alc.free(adr);
	return;
}
#end

func alloc2(size: uxx) ptr {
	let alcs = allocators;
	if alcs == null {
		let size : uxx = 64#uxx * sizeof(ptr);
		let list = sys_alloc(size);
		clear(list, size);
		allocators = list;
		alcs = list;
	}

	let pow = 0#u8;
	let cmp = 16#uxx;
	while cmp < size {
		cmp = cmp << 1;
		pow++;
	}

	let adr : ptr = (alcs @as ptr) + (pow * sizeof(ptr));
	let alc = @ptrv(adr, ?Allocator2, 0);
	if alc == null {
		alc = Allocator2.init(cmp);
		@ptrv(adr, ?Allocator2, 0) = alc;
	}
	// Get chunk
	rep alc = alc @as Allocator2;
	return alc.alloc();
}

func calloc(size: uxx) ptr {
	let res = alloc(size);
	clear(res, size);
	return res;
}

func sys_alloc(size: uxx) ptr {
	return os.ki_os__alloc(size);
}
func sys_free(adr: ptr) void {
	os.ki_os__free(adr);
}

func clear(adrc: ptr, size: uxx) void {
	while(size > sizeof(ptr)){
		@ptrv(adrc, uxx, 0) = 0#uxx;
		adrc += sizeof(ptr);
		size -= sizeof(ptr);
	}
	while(size > 3){
		@ptrv(adrc, u32, 0) = 0#u32;
		adrc += 4;
		size -= 4;
	}
	while(size > 1){
		@ptrv(adrc, u16, 0) = 0#u16;
		adrc += 2;
		size -= 2;
	}
	while(size > 0){
		@ptrv(adrc, u8, 0) = 0#u8;
		adrc+=1;
		size-=1;
	}
}

func copy(from: ptr, to: ptr, len: uxx) void {

	let i = len / sizeof(ptr);
	let y = i;
  	while i > 0 {
	 	i--;
	 	@ptrv(to, uxx, i) = @ptrv(from, uxx, i);
  	}
	len -= y * sizeof(ptr);
	from += y * sizeof(ptr);
	to += y * sizeof(ptr);

  	while(len > 3){
	 	len -= 4;
	 	@ptrv(to, u32, 0) = @ptrv(from, u32, 0);
	 	from += 4;
	 	to += 4;
  	}
  	while(len > 1){
	 	len -= 2;
	 	@ptrv(to, u16, 0) = @ptrv(from, u16, 0);
	 	from += 2;
	 	to += 2;
  	}
  	while (len > 0){
	 	len-=1;
	 	@ptrv(to, u8, 0) = @ptrv(from, u8, 0);
	 	from+=1;
	 	to+=1;
  	}
}

func equal(a: ptr, b: ptr, length: uxx) bool {
	a += length;
	b += length;
	while(length > sizeof(uxx)){
		a -= sizeof(uxx);
		b -= sizeof(uxx);
		let av = @ptrv(a, uxx, 0);
		let bv = @ptrv(b, uxx, 0);
		if(av != bv) {
			return false;
		}
		length -= sizeof(uxx);
	}
	while(length > 3){
		a -= 4;
		b -= 4;
		let av = @ptrv(a, u32, 0);
		let bv = @ptrv(b, u32, 0);
		if(av != bv) {
			return false;
		}
		length -= 4;
	}
	while(length > 0){
		a--;
		b--;
		let av = @ptrv(a, u8, 0);
		let bv = @ptrv(b, u8, 0);
		if(av != bv) {
			return false;
		}
		length--;
	}
	return true;
}
