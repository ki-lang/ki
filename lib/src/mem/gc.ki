
// Allocator starts with 1 chunk (4 slots)
// All slot addresses are stored in a free_slot array

// When allocating we take the first item in the free_slot array and return it
// If no spots left, we do a RC check on all objects
// If RC == 0 | add to free_slot array

// If free_slot count < 25% of total slot count : try removing empty blocks until total slots is reduced by 50% 
// If free_slot count > 75% of total slot count : Create a new block and dubble the total slot count
// return first item in the free_slot array

struct Alc[T] {

	let block_list: ptr;
	let block_list_size: uxx;

	let block_index: uxx = 0;
	let current_block: ptr;

	let slot_total: uxx;
	let slot_free: uxx;

	let free_list: uxx;

	static instance: CLASS;

	func get_instance() &CLASS {

		let alc = CLASS.instance ?! {

			let block_list_size = 10;
			let block_list = mem:alloc(block_list_size * sizeof(ptr));

			let slot_total = 4;
			let free_list = mem:alloc(slot_total * sizeof(ptr));

			let block = mem:calloc(slot_total * sizeof_class(T));

			@ptrv(block_list, ptr, 0) = block;

			let i = slot_total;
			while(i < slot_total) {
				@ptrv(free_list, ptr, i) = block + (i * sizeof_class(T));
				i++;
			}

			let alc = CLASS {
				block_list_size: free_list,
				block_list: block_list,

				current_block: block,

				slot_total: slot_total,
				slot_free: slot_total,
				free_list: free_list,
			};

			let res = &alc;
			CLASS.instance = alc;
			return res;
		};

		return alc;
	}

	func alloc() ptr {
		let alc = CLASS.get_instance();

		let slot_free = alc.slot_free;
		if slot_free == 0 {
		}
	}
}
