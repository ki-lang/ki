
class ServerRequest {
	method: String = "";
	path: String = "";
	headers: Map[String] = Map[String]{};
	body: String = "";
}

class ParseResult {
	~ status: uxx = 0;
	~ method: String = "";
	~ path: String = "";
	~ headers: Map[String] = Map[String]{};
	~ body: String = "";
	~ content_length: uxx = 0;
	~ fully_parsed: bool = false;
	~ headers_parsed: bool = false;
	- stage: uxx = 0;
	- buffer: ByteBuffer = ByteBuffer.new(100);
}

class Parser {

	static fn parse_response(bytes: *ByteBuffer, result: *ParseResult, only_headers: bool = false) !invalid {
		Parser.parse_bytes(bytes, result, only_headers, false) !! throw invalid;;
	}
	static fn parse_request(bytes: *ByteBuffer, result: *ParseResult, only_headers: bool = false) !invalid {
		Parser.parse_bytes(bytes, result, only_headers, true) !! throw invalid;;
	}

	- static fn parse_bytes(bytes: *ByteBuffer, result: *ParseResult, only_headers: bool, is_request: bool) !invalid {

		// Stage 0. Protocol & status
		// Stage 1. Headers
		// Stage 2. Body
		// Stage 3. Done

		if result.fully_parsed {
			result.stage = 0;
			result.buffer.clear();
			result.headers_parsed = false;
			result.fully_parsed = false;
			result.content_length = 0;
			result.status = 0;
			result.body = "";
			result.headers.clear();
		}

		let line = result.buffer;
		let stage = result.stage;
		let data = bytes.data;
		let pos = bytes.start_index;
		let length = bytes.length;
		let content_len = result.content_length;

		if stage > 2 && only_headers {
			return;
		}

		let status_str = "200";

		let ch = (pos > 0) ? @ptrv(data, u8, pos - 1) : '\0';
		let prev_ch = '\0';
		while pos < length {
			prev_ch = ch;
			ch = @ptrv(data, u8, pos);
			pos++;

			if stage == 2 {
				line.append_byte(ch);
				if line.length == content_len {
					stage = 3;
					result.stage = stage;
					result.body = line.to_str();
					result.fully_parsed = true;
					break;
				}
				continue;
			}

			if prev_ch == '\r' && ch == '\n' {

				line.length--; // Remove \r

				if stage == 0 {
					// Parse "HTTP/1.1 200 OK"
					stage = 1;
					result.stage = stage;
					line.clear();
					continue;
				}

				// Parse headers
				if line.length == 0 {
					// End of headers
					result.headers_parsed = true;
					stage = 2;
					result.stage = stage;
					line.clear();
					if only_headers {
						break;
					}
					continue;
				}

				let headers = result.headers;
				let split_index = line.index_of_byte(':') !! {
					throw invalid;
				};
				// Key
				let key = line.sub_str(0, split_index).to_lower();
				// Value
				let value_start_index = split_index + 1;
				let value_index = line.index_where_byte_is_not(' ', value_start_index) !? value_start_index;
				let value = line.sub_str(value_index, line.length - value_index);

				if key == "content-length" {
					content_len = value.to_uxx() !! {
						throw invalid;
					};
					result.content_length = content_len;
				}

				headers.set(key, value);
				line.clear();
				continue;
			}
			line.append_byte(ch);
		}

		bytes.start_index = pos;
	}
}
